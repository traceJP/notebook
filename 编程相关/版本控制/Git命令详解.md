# 一、git命令最基本的流程：

第一步：git init  // 创建工作目录 对工作目录进行修改

第二步：git add ./  // 将修改添加到暂存区(./代表当前目录下的所有文件，可以使用单个文件的具体URL代替)

第三步：git commit -m "<注释内容>"  // 将暂存区提交到版本库


## 1、记录更新与状态：

- 工作目录下面的所有文件只有两种状态：已跟踪或未跟踪。

- 已跟踪的文件：本来就被纳入版本控制管理的文件， 在上次快照中有它们的记录，工作一段时间后，它们的状态可能是已提交，已修改或者已暂存

- 未跟踪文件：所有除了已跟踪文件外的其他文件都属于未跟踪文件，它们既没有上次更新时的快照，也不在当前的暂存区域。

- 具体当前问题状态检查：
```shell
git status  // 确定文件当前处于什么状态

/*命令会显示工作目录下所有文件的状态*/
```

（1）新建一个hello文件，此时没有任何操作，hello文件为未跟踪状态（红色）

![clipboard.png](Git%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3.assets/clip_image002.gif)

（2）使用add将hello文件加入暂存区后，hello文件变为已跟踪的已暂存状态（绿色）

![clipboard.png](Git%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3.assets/clip_image004.gif)

（3）使用vim修改hello文件后，hello文件变为两种状态：第一个（绿色）为已暂存的hello文件，第二个（红色）为已跟踪的已修改hello文件。只有当修改后的hello文件重新add加入到暂存区中才能覆盖第一个（绿色）hello文件。

![clipboard.png](Git%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3.assets/clip_image006.gif)

（3.1）如何区分两种状态带来的区别：(原本文件和被修改的文件)
```shell
git diff  // 当前做的哪些更新没被暂存

git diff --cached 或 git diff --staged  // 有哪些更新已经暂存起来，但并没有被提交

/*命令作用：便于区分修改的文件是否有被暂存或提交，以防止提交错误的文件版本*/
```
- 如下图：通过diff命令可以看到修改的hello文件删除了HelloGit文字，新增了Hello和Git文字，这些修改与原本未修改的区别，**以及这些修改并没有被暂存。**

![clipboard.png](Git%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3.assets/clip_image008.gif)

- 如下图：hello已修改文件将暂存区原文件覆盖之后，使用diff --cached命令查看区别，将看到修改的变化，**以及这些修改并没有被提交**。

![clipboard.png](Git%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3.assets/clip_image010.gif)

（4）再次使用add命令将修改后的hello文件加入暂存区，此时暂存区原先文件被覆盖

![clipboard.png](Git%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3.assets/clip_image012.gif)

（5）使用commit命令将文件放入暂存区的再提交后，hello文件变为已跟踪的已提交状态

![clipboard.png](Git%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3.assets/clip_image014.gif)

## 2、文件删除与重命名：

（1）文件删除：
```shell
rm <文件名>  // 删除文件.linux命令

git add  // 删除后的文件要覆盖到暂存区中

git commit  // 暂存区变化提交到版本库

/* 

 \* 删除的只是工作区的文件，其提交对象并没有被删除

 \* 工作目录下做的是删除操作，而版本库中做的是新增操作（新增一个树对象，一个提交对象）

 */
```
（2）重命名：
```shell
mv <原文件名> <新文件名>  // 改名

git add

git commit

/* 

 \* 其改名原理是将原文件删除，并创建一个新文件

 \* 通过改名后提交到版本库中，git会自动识别文件并提示renamed

 */
```
- git命令包装了以上两个操作：（删除与添加到暂存区）
```shell
git rm  // 整合了删除操作的前两个命令

git mv  // 整合了重命名操作的前两个命令
```

## 3、历史记录（日志）：
```shell
git log  // 查看提交历史记录

git log --pretty=oneline  // 使记记录使一行的形式出现

git log --oneline  // 使记录出现更精简
```


# 二、git分支操作：

- 定义：分支是指向最新的一个提交对象的指针，分支意味着你可以把的工作从开发主线上分离开来，以免影响开发主线。在很多版本控制系统中，这是一个略微低效的过程（常常需要完全创建一个源代码目录的副本）。对于大项目来说，这样的过程会耗费很多时间（如SVN中的分支）。而Git的分支模型极其的高效轻量的。

- 解析：在企业级管理中，是不可以直接修改别人的源代码，必须将别人的源代码复制一份，再在这份新代码中修改，这一过程叫做分支操作。

- 如图：其实可以将分支看作一个指针，master分支实际上就是一个指针，他永远指向当前最新的一个提交对象。随着提交对象不断的更新，master分支一直在不断的指向最新的提交对象。

![clipboard.png](Git%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3.assets/clip_image016.gif)

- 其本质是 HEAD -> master ->new提交对象 ，head才是那个灵活的指针。

![clipboard.png](Git%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3.assets/clip_image018.gif)

## 1、创建分支：

- 作用：为你创建了一个可以移动的新的指针，这会在当前所在的提交对象上创建一个指针。
```shell
git branch <分支名>  // 创建一个分支，但不会自动切换到新分支
```

![clipboard.png](Git%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3.assets/clip_image020.gif)

## 2、分支的切换：

- 作用：活动指针的本质是head指针带动分支指针进行迁移，所以需要移动head指针调整到目前分支上
```shell
git checkout <分支名>  // 将head指针指向其他分支名
```

![clipboard.png](Git%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3.assets/clip_image022.gif)

- 此时，假设新的提交对象被创建，head指针带着动当前分支移动到新的提交对象。master(主)分支被保留，以便于版本穿梭使用。

![clipboard.png](Git%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3.assets/clip_image024.gif)

## 2.1、分支切换的注意事项：

- 警告：分支切换会改变三个地方：head指针，工作目录，暂存区

    - 在切换分支时，一定要注意你工作目录里的文件会被改变。如果是切换到一个较旧的分支,你的工作目录会恢复到该分支最后一次提交时的样子。如果Git不能干净利落地完成这个任务，它将禁止切换分支。

    - 原因：随着提交对象的更新，每个对象有每个对象对应的文件，也许第一个提交对象只有1个文件，第二个提交对象有3个文件，那么当从第二个提交对象的分支切换到第一个提交对象的切换分支时，工作目录便从3个文件改变到1个文件。

- 最佳操作：每次切换分支前，当前分支一定得是干净的（status命令下无绿无红/已提交状态）

- 大坑：在初始化的情况下（未进行第一次提交操作时）当前分支不干净的情况下切换分支

    - 假设当前分支下，工作目录有一个文件未被跟踪或在暂存区上保留，进行分支切换后，该文件会被保留（git安全机制不希望你的数据丢失）到其他分支下或被保留到其他分支的暂存区中，从而严重污染了其他分支的工作目录。

    - 在进行一次提交操作后，文件被修改时，分支若处于不干净状态，那么git将禁止你切换分支。

## 3、分支的删除：

- 作用：当发现新的分支并不需要时，可以回退到之前的分支，并删除新的分支。
```shell
/*在删除分支前，需要使用chekout命令切换到其他分支，再进行删除*/

git branch -d <分支名>  // 删除分支

git branch -D <分支名>  // 强制删除分支（分支上有内容，且该内容并未被合并，此时git安全机制不希望你错误删除）
```

![clipboard.png](Git%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3.assets/clip_image026.gif)

## 4、分支的合并：

- 作用：当新分支的功能做好且运行无误之后，需要将其合并到master(主)分支上。

- 合并命令：

    - 此种合并命令叫快进合并（fast-forward）。
```shell
git merge <分支名>  // 将<分支名>的分支合并到当前分支下

/* 注意：是副分支合并到主分支，而不是主分支合并到副分支，所以应当切换到主分支进行合并命令的操作*/
```
（1）快进合并下产生的错误：

![clipboard.png](Git%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3.assets/clip_image028.gif)

- 在合并的时候，有时候会出现"快进(fast-forward)"这个词。由于当前master分支所指向的提交是你当前提交的直接上游，所以Git只是简单的将指针向前移动。换句话说，当你试图合并两个分支时，如果顺着一个分支走下去能够到达另一个分支，那么Git在合并两者的时候，只会简单的将指针向前推进(指针右移) ,因为这种情况下的合并操作没有需要解决的分歧，这就叫做 快进(fast-forward)。

（2）此时，假设hotfix改动了C2文件，iss53也改动了C2文件，那么，再将iss53分支合并到master分支上去时，将出现冲突问题。

![clipboard.png](Git%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3.assets/clip_image030.gif)

（3）解决冲突：

- 解释：当两个分支出现文件冲突时，直接合并过后，git将产生一种“合并冲突而处于未合并状态的文件（冲突文件）”，此时分析冲突文件（分析冲突文件的代码，修改代码使其与其他分支不冲突），进行修改之后跟踪提交即可。

（4）分支合并后：

- 分支合并后需要将副分支删除，因为分支合并过程仅是移动指针，其分支并未自动消失，需要手动删除。


- 在企业中，对源代码进行修改通过创建分支，在分支上做修改（这里假设叫这个分支为 修改分支）。这样，当你修改的没有任何问题，即可将master(主)分支和修改分支合并即可，若是当修改分支不小心做坏了，只需要将hard指针指回master(主)分支即可实现版本回退效果。

## 5、Git存储：

- 解释：当在一个分支上的工作尚未做完时，便需要切换到其他分支。而此时，你并不想把你做到一半的分支上的任务创建一次提交，针对这个问题git允许你将分支任务进行储存，存储之后暂存区为干净状态即可切换分支。

- 原理：它将你的文件进行一次隐性的提交（这次提交不会被记录到日志上），随后将该提交对象压进栈中，等待下一次的弹栈操作。

## 6、存储命令：

- 命令会将未完成的修改保存到一个栈（后进先出）上， 而你可以在任何时候重新应用这些改动
```shell
git stash  // 将文件保存在栈中

git stash apply  // 应用栈中文件元素（应用即该元素的复制被取出，栈内并没有被删除）

git stash pop  // 弹栈操作，应用并删除元素
```
- 查看栈中文件元素：
```shell
git stash list  // 查看存储
```
- 删除栈内文件元素：
```shell
git stash drop stash@{n}   // stash@{n}为栈内元素的名称，具体可以通过查看命令查看名称
```

# 三、Git后悔药：

- 定义：git三大后悔药：撤回自己在工作区的修改、撤回自己的暂存、撤回自己的提交（前提：只能撤回被git管理的文件）

## 1、撤回工作目录的修改：

```shell
git checkout --<文件名>  // 撤回文件的修改
```
## 2、撤回暂存：

```shell
git reset HEAD <文件名>  // 将文件从暂存区中撤回
```
## 3、撤回提交：

- 提交的撤回只需要将暂存区的文件修改后重新提交覆盖即可，但这种覆盖会被记录到日志中。所以当提交注释写错时，可以使用撤回命令，这样，错误的提交就不会被记录，从而避免污染正常的日志信息。

- 实际上，版本库中的撤销只能重新给用户修改注释的功能，再进行重复的提交，并无撤销功能，本质是通过重复提交和新的注释覆盖日志中的记录。
```shell
git commit --amend  // 重新书写日志，并暂存区的文件重新提交，从而覆盖原提交记录（需要先修改暂存区文件）
```

## 4、撤销命令原理详解：（!底层命令!）reset三部曲：

（1）移动head指针：（--ameng实现）

- 这与checkout命令改变head指针指向不同，reset移动的是head和head指向的分支（head带着分支一起移动）。

- 如图，退回到v2版本后，再此创建提交对象时会出现分支，v3版本在版本库记录中始终存在。

![clipboard.png](Git%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3.assets/clip_image032.gif)
```shell
git reset --soft <HEAD~ or 提交对象哈希>  // 将head指针以及head所指向的分支一起移动到上一个或其他的提交对象上

/*HEAD~：head指针前一次的指向*/
```

（2）暂存区的变化：

- 它依然会对head指针以及head指向的分支进行移动，但还会取消所有暂存的东西。于是，我们就回滚到了add和commit命令之前。

![clipboard.png](Git%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3.assets/clip_image034.gif)
```shell
git reset [--mixed] HEAD~  // 将head和分支移动到其他提交对象，且暂存区也变动到其他提交对象
```

（3）工作目录的变化：

- 它撤销了最后的提交、add和commit命令以及工作目录中的所有工作

- 与checout的区别：两者同样是对三个区域进行改变，但是checout只动head指针，而并不会带动分支一起移动。

- checout的底层命令就是在这个命令上的优化（数据保护机制优化）。

![clipboard.png](Git%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3.assets/clip_image036.gif)
```shell
git reset --hard HEAD~  // 将head和分支移动到其他提交对象，且暂存区和工作目录也变动到其他提交对象
```


（4）注意：

- 必须注意，--hard标记是reset命令唯一的危险用法，它也是 Git 会真正地销毁数据的仅有的几个操作之一。其他任何形式的reset调用都可以轻松撤消,但是--hard选项不能，因为它强制覆盖了工作目录中的文件。在这种特殊情况下,我们的Git数据库中的一个提交内还留有该文件的v3版本，我们可以通过reflog,来找回它。但是若该文件还未提交，Git仍会覆盖它从而导致无法恢复。

 

（5）路径reset：（命令带上路径所展现的区别）

- 通过指定提交对象中具体的文件名，从而跳过head指针及head指针所指向的分支移动。所以该命令最终只动暂存区。

- 其本质上只是将文件覆盖到暂存区中（git的撤销命令基本都是在执行覆盖操作）

![clipboard.png](Git%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3.assets/clip_image038.gif)

- 如上图：命令通过工作目录覆盖操作更新暂存区
```shell
git reset [--mixed] HEAD <文件名>  // 工作区目录覆盖暂存区
```


![clipboard.png](Git%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3.assets/clip_image040.gif)

- 如上图：命令通过commithash覆盖操作更新暂存区
```shell
git reset <文件名>  // 默认用head指向的提交对象覆盖暂存区
```

## 5、数据恢复：

- 解释：在使用git的时候，可能会出现意外丢失的一次提交，这可能是因为你使用了-D强制删除了正在工作的分支所造成的等等。那么找回这个分支就称为数据恢复。

- 通过reflog命令查看所有分支的每一次命令操作命令，记录下丢失的提交对象哈希值即可。
```shell
git reflog
```
- 推荐操作：记录下哈希值后，将这个提交对象单独创建一个分支，以便于后续操作。


# 四、Git其他命令补充

## 1、打tag

- 解释：Git可以给历史中的某一个提交打上标签，以标记重要的版本号。如使用打tag功能标记发布结点（v1.0等等）

（1）创建标签：

- git使用两种主要的标签类型：轻量标签、附注标签

- 轻量标签：轻量标签很像一个不会改变(永远固定的)的分支，它只是一个特定提交的引用。
```shell
git tag <标签名> [<提交对象哈希>]  // 创建一个标签，默认在当前提交对象
```
（2）列出标签：
```shell
git tag  // 列出所有标签

git tag -l '<标签名>[通配符]'  // 根据字段查找对应的标签，通配符具体参考mysql通配符
```
（3）查看标签：
```shell
git show <标签名>  // 该命令可以显示任意类型的对象（如git对象，tag对象等等）
```
（4）删除标签：
```shell
git tag -d <标签名>  // 删除对应的标签
```
（5）检出标签：（查看标签所指向的文件版本）：

- 注意：使用checkout命令检出标签后，将处于头部分离的模式（即head指针将不会指向任何分支），所以在检出标签后一定要在该标签上创建分支，使head指针指向分支。否则，新的提交将不属于任何分支，并且该提交将无法访问。
```shell
git checkout <标签名>  // head指针移动到检出标签的提交对象上方，但不会指向

git checkout -b <分支名>  // 创建分支，将head指针指向该分支
```

## 2、配置命令别名：

- 解释：在输入git命令的时候，git并没有补全功能，所以当一个命令很长的时候，可以给他重新设置一个别名，只需要输入别名即可允许原命令。
```shell
git config --global alias.<别名命令> "<原代码>"

eg：

git config --global alias.lol git init  // 只需要输入lol即可允许创建版本库命令
```

